<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何永久使用 ELK 白金段位]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%A6%82%E4%BD%95%E6%B0%B8%E4%B9%85%E4%BD%BF%E7%94%A8-ELK-%E7%99%BD%E9%87%91%E6%AE%B5%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[为啥要上白金段位因为有些高级功能只有白金段位才会有，虽然一开始有30天的试用，但30天不够啊 如果不知道 ELK 是干啥的可以看看这个 搭建 ELK 7.x 日志分析平台 1234# 先把 x-pack 拷贝出来sudo cp /usr/share/elasticsearch/modules/x-pack-core/x-pack-core-7.0.1.jar ./# 解压到x-pack-core目录unzip x-pack-core-7.0.1.jar -d x-pack-core 下面我们需要一个 java 反编译工具，建议使用luyten（本人用过jd-gui和jad反编出来都有问题），找到 org/elasticsearch/license/LicenseVerifier.class 和 org/elasticsearch/xpack/core/XPackBuild.class 反编译得到 LicenseVerifier.java 后，将里面的verifyLicense和verifyLicense方法改为如下内容，让许可的验证都返回true 123456789101112131415161718192021package org.elasticsearch.license;import java.nio.*;import org.elasticsearch.common.bytes.*;import java.security.*;import java.util.*;import org.elasticsearch.common.xcontent.*;import org.apache.lucene.util.*;import org.elasticsearch.core.internal.io.*;import java.io.*;public class LicenseVerifier&#123; public static boolean verifyLicense(final License license, final byte[] publicKeyData) &#123; return true; &#125; public static boolean verifyLicense(final License license) &#123; return true; &#125;&#125; 反编译得到 XPackBuild.java 后，将里面的 if (path.toString().endsWith(&quot;.jar&quot;)) 那段语句注释或者删除掉，让程序检测不到jar包被修改过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package org.elasticsearch.xpack.core;import org.elasticsearch.common.io.*;import java.net.*;import org.elasticsearch.common.*;import java.nio.file.*;import java.io.*;import java.util.jar.*;public class XPackBuild&#123; public static final XPackBuild CURRENT; private String shortHash; private String date; @SuppressForbidden(reason = "looks up path of xpack.jar directly") static Path getElasticsearchCodebase() &#123; final URL url = XPackBuild.class.getProtectionDomain().getCodeSource().getLocation(); try &#123; return PathUtils.get(url.toURI()); &#125; catch (URISyntaxException bogus) &#123; throw new RuntimeException(bogus); &#125; &#125; XPackBuild(final String shortHash, final String date) &#123; this.shortHash = shortHash; this.date = date; &#125; public String shortHash() &#123; return this.shortHash; &#125; public String date() &#123; return this.date; &#125; static &#123; final Path path = getElasticsearchCodebase(); String shortHash = null; String date = null; Label_0109: &#123; // if (path.toString().endsWith(".jar")) &#123; // try &#123; // final JarInputStream jar = new JarInputStream(Files.newInputStream(path, new OpenOption[0])); // try &#123; // final Manifest manifest = jar.getManifest(); // shortHash = manifest.getMainAttributes().getValue("Change"); // date = manifest.getMainAttributes().getValue("Build-Date"); // jar.close(); // &#125; // catch (Throwable t) &#123; // try &#123; // jar.close(); // &#125; // catch (Throwable t2) &#123; // t.addSuppressed(t2); // &#125; // throw t; // &#125; // break Label_0109; // &#125; // catch (IOException e) &#123; // throw new RuntimeException(e); // &#125; // &#125; shortHash = "Unknown"; date = "Unknown"; &#125; CURRENT = new XPackBuild(shortHash, date); &#125;&#125; 注意不要直接复制这些代码，修改仅供参考，有可能其他版本的代码会有点不一样，所以代码参考去改就好了 修改完后，把 LicenseVerifier.java 和 XPackBuild.java 重新编译123javac -cp "/usr/share/elasticsearch/lib/elasticsearch-7.0.1.jar:/usr/share/elasticsearch/lib/lucene-core-8.0.0.jar:/usr/share/elasticsearch/modules/x-pack-core/x-pack-core-7.0.1.jar:/usr/share/elasticsearch/lib/elasticsearch-core-7.0.1.jar" LicenseVerifier.javajavac -cp "/usr/share/elasticsearch/lib/elasticsearch-7.0.1.jar:/usr/share/elasticsearch/lib/lucene-core-8.0.0.jar:/usr/share/elasticsearch/modules/x-pack-core/x-pack-core-7.0.1.jar:/usr/share/elasticsearch/lib/elasticsearch-core-7.0.1.jar" XPackBuild.java 注意编译需要依赖这些包，所以请根据自己安装的版本去选择这包 编译完成后，将得到的 LicenseVerifier.class 和 XPackBuild.class 覆盖到 org/elasticsearch/license/LicenseVerifier.class 和 org/elasticsearch/xpack/core/XPackBuild.class 最后重新打包jar 12345678cd x-pack-core# 打包当前目录jar -cvf x-pack-core-7.0.1.jar ./# 打包好之后 覆盖原来的jar包sudo cp x-pack-core-7.0.1.jar /usr/share/elasticsearch/modules/x-pack-core/# 重启sudo service elasticsearch restart 去注册一个免费一年的License https://license.elastic.co/registration，注册完成后会给你发送下载地址 下载之后你会得到一个json文件12345678910111213&#123; "license": &#123; "uid": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "type": "basic", "issue_date_in_millis": 1557705600000, "expiry_date_in_millis": 1589414399999, "max_nodes": 100, "issued_to": "~~~~~~~~~~~", "issuer": "Web Form", "signature": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "start_date_in_millis": 1557705600000 &#125;&#125; 将type的参数改为platinum(即：‘白金版’) 将expiry_date_in_millis 的参数改成你想要的过期时间（这里用的是毫秒）可以改为4070883661000过期时间都是到2099年~~~ 其他参数尽量不要改 12345678910111213&#123; "license": &#123; "uid": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "type": "platinum", "issue_date_in_millis": 1557705600000, "expiry_date_in_millis": 4070883661000, "max_nodes": 100, "issued_to": "~~~~~~~~~~~", "issuer": "Web Form", "signature": "~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "start_date_in_millis": 1557705600000 &#125;&#125; 修改 /etc/elasticsearch/elasticsearch.yml 暂时先关闭 xpack (记得重启elasticsearch)1xpack.security.enabled: false 在 kibana 中 管理 → 许可管理 → 更新许可 修改 /etc/elasticsearch/elasticsearch.yml 重新打开 xpack (记得重启elasticsearch)1xpack.security.enabled: true 更新后显示这样就ok了]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Elasticsearch</tag>
        <tag>Kibana</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建 ELK 7.x 日志分析平台]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%90%AD%E5%BB%BA-ELK-7-x-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[前言由于公司项目众多，要对这么多项目日志进行巡查和监控，一个个去查，效率会比较低。因此需要一个对日志进行统一管理的工具。so 本人就采用了 ELK 方案。 什么是 ELK ❓ELK 是由 Elasticsearch + Logstash + Kibana 这三个工具组成的一套开源日志监控、日志可视化管理的解决方案 安装 ⚙️这里有两种安装方式，apt 常规安装 和 Docker 方式。本人在公司采用的是 apt 常规安装，自用的服务器是用 Docker 方式 apt常规安装前期准备 本文使用环境：Ubuntu 16.04.4 LTSJdk 1.8.0_191Elasticsearch 7.0.1Kibana 7.0.1Logstash 7.0.1 1234567wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -sudo apt-get install apt-transport-httpsecho "deb https://artifacts.elastic.co/packages/7.x/apt stable main" | sudo tee -a /etc/apt/sources.list.d/elastic-7.x.listsudo apt-get update 12# 官网的速度有点忙，想快点的话，这里可以换成国内镜像echo "deb https://artifacts.elastic.co/packages/7.x/apt stable main" | sudo tee -a /etc/apt/sources.list.d/elastic-7.x.list 安装 elasticsearch kibana logstash1sudo apt-get install elasticsearch kibana logstash 注意：ELK 依赖 Java，务必安装好 Java。（ 本人之前用 Java 9 好像有点问题，如果用 Java 9 也遇到问题，可以尝试改为Java 8 ） 配置先配置一下 elasticsearch /etc/elasticsearch/elasticsearch.yml123network.host: 0.0.0.0http.port: 9200cluster.initial_master_nodes: ["node-1"] 接着配置一下 kibana /etc/kibana/kibana.yml12345server.port: 5601server.host: 0.0.0.0elasticsearch.hosts: ["http://127.0.0.1:9200"]# 可以使用中文i18n.locale: "zh-CN" 最后重启一下 elasticsearch &amp; kibana 12sudo service elasticsearch restartsudo service kibana restart 最后访问一下 http://127.0.0.1:5601 能进入到 kibana 就OK了 Docker 方式这里我是用 deviantony 编写好的 docker-composer 脚本 docker-elk 123git clone https://github.com/deviantony/docker-elk.gitcd docker-elkdocker-composer up -d 等docker构建完，就可以访问 http://127.0.0.1:5601 开启用户管理因为 ELK 是没有登录，用户管理等功能，所以我们要开启 x-pack 。 由于 x-pack 是付费功能，在 kibana 中 管理 → 许可管理 在/etc/elasticsearch/elasticsearch.yml添加xpack.security.enabled: true。添加完后记得重启sudo service elasticsearch restart 设置密码 1234# 这个是手动设置密码sudo /usr/share/elasticsearch/bin/elasticsearch-setup-passwords interactive# 如果不想手动设置密码，也可以使用自动设置sudo /usr/share/elasticsearch/bin/elasticsearch-setup-passwords auto 设置好密码后，在/etc/kibana/kibana.yml添加。（添加好后记得重启kibana sudo service kibana restart） 12elasticsearch.username: "elastic"elasticsearch.password: "这里填写你设置的密码" 最后访问 http://127.0.0.1:5601]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>Elasticsearch</tag>
        <tag>Kibana</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在 ionic 3 中使用 URL Scheme]]></title>
    <url>%2F2018%2F02%2F03%2F%E5%A6%82%E4%BD%95%E5%9C%A8-ionic-3-%E4%B8%AD%E4%BD%BF%E7%94%A8-URL-Scheme%2F</url>
    <content type="text"><![CDATA[虾扯蛋🥚第一次在掘金写东西，有点紧张。 我为啥写这个，是因为我最近用 ionic 开发一个 app ，需要用 URL Scheme 。搞这个 URL Scheme 折腾了一下，所以写下此文，并分享给需要的朋友。😝 什么是 URL Scheme❓简单的说，URL Scheme就是一个可以让app相互之间可以跳转的协议。列如：微信的 URL Scheme 就是 weixin://，在浏览器中打开 weixin://scanqrcode 可以跳转到微信的扫一扫功能。 更多 URL Scheme ：https://www.zhihu.com/question/19907735 开始撸代码 💻构建demo 🐒我们就用ionic的tabs模板构建一个demo吧 1ionic start myApp tabs 安装 URL Scheme Cordova 插件 🔧我们需要的安装的 URL Scheme Cordova 插件是cordova-plugin-customurlscheme 插件地址：https://github.com/EddyVerbruggen/Custom-URL-scheme 1ionic cordova plugin add cordova-plugin-customurlscheme --variable URL_SCHEME=myapp-mak 在根目录使用此命令进行安装,URL_SCHEME=myapp-mak我定义的协议名称是myapp-mak。名称随便起，只要不跟其他app冲突就好。😝 如果安装后想修改协议名称的，可以去改config.xml和package.json。打开就能看到之前定义的协议名称了 编译安装app到手机上📱1ionic cordova run ios 编译安装完成后，可以通过这个协议myapp-mak://随便写打开此app。如：在浏览器打开myapp-mak://test 如何知道是哪个URL打开的App❓ 获取url 12345//获取url并显示在页面上(window as any).handleOpenURL = (url: string) =&gt; &#123; console.log(url); this.url = url;&#125;; 这句代码是获取是哪个URL打开的app了。 注意：handleOpenURL函数必须是全局唯一，否则无法正常接收 修改config.xml 1&lt;allow-intent href=&quot;myapp-mak:*&quot; /&gt; 这里必须写上这句话，这句是允许我们定义的协议可以传递。否则handleOpenURL也无法接收到URL 测试 ⚙ 重新编译安装 1ionic cordova run ios 在浏览器打开myapp-mak://test 获取URL有啥作用呢？获取URL之后，我们可以判断URL的不同进行不同的操作，例如：打开指定页面、分享、支付…… 结束 😁第一次写文，写得不是很好。😜 除了通过URL Scheme方式来打开app。其实可以使用Universal Links &amp;&amp; Deep Linking 来打开app。 分享一个 Universal Links &amp;&amp; Deep Linking Cordova 插件给大家https://github.com/nordnet/cordova-universal-links-plugin]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Ionic</tag>
        <tag>JavaScript</tag>
        <tag>Angular</tag>
        <tag>Android</tag>
        <tag>IOS</tag>
        <tag>App</tag>
      </tags>
  </entry>
</search>
